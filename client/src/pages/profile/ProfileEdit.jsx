// portall/client/src/pages/profile/ProfileEdit.jsx
import { useState, useEffect, useCallback } from 'react'
import { useAuth } from '@contexts/AuthContext'
import { useNavigate } from 'react-router-dom'
import DashboardHeader from '@components/dashboard/DashboardHeader'
import toast from 'react-hot-toast'

/**
 * ‚úèÔ∏è Page d'√âdition de Profil - Interface Adaptative Phase 5B
 * 
 * Cette page illustre un concept architectural fondamental : "l'interface polymorphe".
 * Comme un cam√©l√©on change de couleur selon son environnement, cette page change
 * de structure et de contenu selon le type d'utilisateur, tout en conservant
 * une logique de base coh√©rente.
 * 
 * üéØ Concept p√©dagogique : "Adaptive Form Architecture"
 * Imaginez cette page comme un formulaire intelligent qui pose les bonnes questions
 * √† la bonne personne. Un joueur verra des champs li√©s √† ses performances sportives,
 * un coach verra des champs li√©s √† son exp√©rience d'entra√Ænement, etc.
 * 
 * üèóÔ∏è Architecture en couches :
 * 1. Couche de donn√©es : Gestion de l'√©tat et des appels API
 * 2. Couche de logique : Validation et transformation des donn√©es
 * 3. Couche de pr√©sentation : Interface adapt√©e au type d'utilisateur
 * 4. Couche d'interaction : Gestion des √©v√©nements et feedbacks
 * 
 * Cette s√©paration claire facilite la maintenance et l'extension du syst√®me
 * quand de nouveaux types d'utilisateurs ou de nouveaux champs sont ajout√©s.
 */
function ProfileEdit() {
  const { user, updateUser } = useAuth()
  const navigate = useNavigate()

  // √âtats pour la gestion du formulaire et de l'interface
  const [profileData, setProfileData] = useState({})
  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [formErrors, setFormErrors] = useState({})
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

  /**
   * üì° Chargement initial des donn√©es de profil
   * 
   * Cette fonction illustre comment g√©rer l'hydratation d'un formulaire complexe
   * avec des donn√©es provenant de diff√©rentes sources selon le type d'utilisateur.
   * C'est comme assembler un puzzle o√π chaque pi√®ce vient d'un endroit diff√©rent.
   */
  useEffect(() => {
    const loadProfileData = async () => {
      try {
        setIsLoading(true)
        
        console.log(`üìä Loading profile data for ${user?.userType} user`)
        
        // Construction de l'endpoint selon le type d'utilisateur
        // Cette logique illustre le principe de "routing adaptatif"
        const endpoint = getProfileEndpoint(user?.userType)
        
        const response = await fetch(endpoint, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
            'Content-Type': 'application/json'
          }
        })

        if (response.ok) {
          const data = await response.json()
          
          // Normalisation des donn√©es selon le sch√©ma attendu par le formulaire
          const normalizedData = normalizeProfileData(data.data, user?.userType)
          setProfileData(normalizedData)
          
          console.log('‚úÖ Profile data loaded and normalized successfully')
        } else {
          throw new Error('Failed to load profile data')
        }
      } catch (error) {
        console.error('‚ùå Error loading profile data:', error)
        toast.error('Failed to load profile information')
        
        // Initialisation avec des donn√©es par d√©faut pour √©viter les erreurs
        setProfileData(getDefaultProfileData(user?.userType))
      } finally {
        setIsLoading(false)
      }
    }

    if (user?.userType) {
      loadProfileData()
    }
  }, [user?.userType])

  /**
   * üõ°Ô∏è Protection contre la perte de donn√©es
   * 
   * Cette fonction illustre un pattern important : la pr√©vention de la perte accidentelle
   * de donn√©es utilisateur. C'est comme un filet de s√©curit√© qui emp√™che l'utilisateur
   * de quitter accidentellement la page avec des modifications non sauvegard√©es.
   */
  useEffect(() => {
    const handleBeforeUnload = (event) => {
      if (hasUnsavedChanges) {
        event.preventDefault()
        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
        return event.returnValue
      }
    }

    window.addEventListener('beforeunload', handleBeforeUnload)
    return () => window.removeEventListener('beforeunload', handleBeforeUnload)
  }, [hasUnsavedChanges])

  /**
   * üîÑ Gestion intelligente des changements de formulaire
   * 
   * Cette fonction illustre le concept de "reactive state management". Chaque changement
   * dans le formulaire d√©clenche une s√©rie de validations et de mises √† jour d'√©tat
   * qui maintiennent la coh√©rence et la qualit√© des donn√©es.
   */
  const handleInputChange = useCallback((field, value) => {
    console.log(`üìù Profile field changed: ${field}`)
    
    setProfileData(prev => ({
      ...prev,
      [field]: value
    }))
    
    // Marquer qu'il y a des changements non sauvegard√©s
    setHasUnsavedChanges(true)
    
    // Effacer l'erreur du champ modifi√© (validation r√©active)
    if (formErrors[field]) {
      setFormErrors(prev => {
        const newErrors = { ...prev }
        delete newErrors[field]
        return newErrors
      })
    }
    
    // Validation en temps r√©el pour les champs critiques
    validateFieldRealTime(field, value, user?.userType)
  }, [formErrors, user?.userType])

  /**
   * ‚úÖ Validation contextuelle des donn√©es
   * 
   * Cette fonction illustre comment impl√©menter une validation intelligente qui
   * s'adapte aux r√®gles m√©tier sp√©cifiques de chaque type d'utilisateur.
   * C'est comme avoir un assistant expert qui conna√Æt les exigences de chaque domaine.
   */
  const validateProfile = useCallback(() => {
    const errors = {}
    
    // Validation commune √† tous les utilisateurs
    if (!profileData.firstName?.trim()) {
      errors.firstName = 'First name is required'
    }
    
    if (!profileData.lastName?.trim()) {
      errors.lastName = 'Last name is required'
    }
    
    if (!profileData.email?.trim()) {
      errors.email = 'Email is required'
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(profileData.email)) {
      errors.email = 'Please enter a valid email address'
    }
    
    // Validation sp√©cifique selon le type d'utilisateur
    switch (user?.userType) {
      case 'player':
        errors = { ...errors, ...validatePlayerSpecificFields(profileData) }
        break
      case 'coach':
      case 'njcaa_coach':
        errors = { ...errors, ...validateCoachSpecificFields(profileData) }
        break
      case 'admin':
        errors = { ...errors, ...validateAdminSpecificFields(profileData) }
        break
    }
    
    setFormErrors(errors)
    return Object.keys(errors).length === 0
  }, [profileData, user?.userType])

  /**
   * üíæ Sauvegarde intelligente du profil
   * 
   * Cette fonction illustre la gestion d'une op√©ration complexe avec feedback utilisateur
   * en temps r√©el. Elle coordonne la validation, l'envoi des donn√©es, et la gestion
   * des √©tats d'interface pour une exp√©rience utilisateur fluide.
   */
  const handleSaveProfile = useCallback(async () => {
    console.log('üíæ Attempting to save profile changes...')
    
    // Validation avant sauvegarde
    if (!validateProfile()) {
      toast.error('Please correct the errors before saving')
      return
    }
    
    try {
      setIsSaving(true)
      
      // Construction des donn√©es √† envoyer selon le format attendu par l'API
      const payload = transformProfileDataForAPI(profileData, user?.userType)
      
      // Endpoint sp√©cifique selon le type d'utilisateur
      const endpoint = getProfileUpdateEndpoint(user?.userType)
      
      const response = await fetch(endpoint, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      })

      if (response.ok) {
        const result = await response.json()
        
        // Mise √† jour du contexte utilisateur si n√©cessaire
        if (result.data.user) {
          updateUser(result.data.user)
        }
        
        setHasUnsavedChanges(false)
        toast.success('Profile updated successfully!')
        
        console.log('‚úÖ Profile saved successfully')
        
        // Redirection optionnelle vers la vue du profil
        // navigate('/profile/view')
      } else {
        const errorData = await response.json()
        throw new Error(errorData.message || 'Failed to update profile')
      }
    } catch (error) {
      console.error('‚ùå Error saving profile:', error)
      toast.error(error.message || 'Failed to save profile changes')
    } finally {
      setIsSaving(false)
    }
  }, [profileData, user?.userType, validateProfile, updateUser])

  /**
   * üé® G√©n√©ration du formulaire adaptatif
   * 
   * Cette fonction illustre le concept de "dynamic form generation". Au lieu d'avoir
   * des formulaires s√©par√©s pour chaque type d'utilisateur, nous g√©n√©rons dynamiquement
   * les champs appropri√©s. C'est comme avoir un moule qui change de forme selon le besoin.
   */
  const renderFormSections = () => {
    const sections = []
    
    // Section commune : Informations personnelles
    sections.push(renderPersonalInfoSection())
    
    // Sections sp√©cifiques selon le type d'utilisateur
    switch (user?.userType) {
      case 'player':
        sections.push(
          renderPlayerAthleticInfo(),
          renderPlayerAcademicInfo(),
          renderPlayerContactPreferences()
        )
        break
        
      case 'coach':
        sections.push(
          renderCoachExperience(),
          renderCoachInstitutionInfo(),
          renderCoachRecruitmentPreferences()
        )
        break
        
      case 'njcaa_coach':
        sections.push(
          renderNJCAACoachInfo(),
          renderTeamManagementPreferences(),
          renderEvaluationSettings()
        )
        break
        
      case 'admin':
        sections.push(
          renderAdminPermissions(),
          renderSystemPreferences()
        )
        break
    }
    
    return sections.filter(Boolean) // √âliminer les sections nulles ou vides
  }

  /**
   * üì± Interface de chargement pendant l'hydratation des donn√©es
   */
  if (isLoading) {
    return (
      <div className="profile-edit profile-edit--loading">
        <DashboardHeader 
          title="Edit Profile" 
          subtitle="Loading your profile information..."
        />
        <div className="profile-edit__loading">
          <div className="loading-spinner">
            <div className="spinner"></div>
            <p>Loading your profile data...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className={`profile-edit profile-edit--${user?.userType}`}>
      {/* üì± En-t√™te avec actions de sauvegarde */}
      <DashboardHeader
        title="Edit Profile"
        subtitle="Update your information and preferences"
        customActions={
          <div className="profile-edit__header-actions">
            <button
              onClick={() => navigate('/profile/view')}
              className="btn btn--outline btn--sm"
              disabled={isSaving}
            >
              üëÅÔ∏è Preview
            </button>
            <button
              onClick={handleSaveProfile}
              disabled={isSaving || !hasUnsavedChanges}
              className="btn btn--primary btn--sm"
            >
              {isSaving ? 'Saving...' : 'üíæ Save Changes'}
            </button>
          </div>
        }
      />

      {/* üìù Contenu principal du formulaire */}
      <main className="profile-edit__main">
        <div className="profile-edit__container">
          
          {/* üö® Indicateur de changements non sauvegard√©s */}
          {hasUnsavedChanges && (
            <div className="profile-edit__unsaved-banner">
              <div className="unsaved-banner">
                <span className="unsaved-banner__icon">‚ö†Ô∏è</span>
                <span className="unsaved-banner__text">
                  You have unsaved changes
                </span>
                <button
                  onClick={handleSaveProfile}
                  className="unsaved-banner__save-btn"
                  disabled={isSaving}
                >
                  Save Now
                </button>
              </div>
            </div>
          )}

          {/* üìã Formulaire adaptatif par sections */}
          <form className="profile-edit__form" onSubmit={(e) => e.preventDefault()}>
            {renderFormSections()}
          </form>

          {/* üéØ Actions de pied de page */}
          <div className="profile-edit__footer">
            <div className="profile-edit__footer-actions">
              <button
                onClick={() => navigate(-1)}
                className="btn btn--outline"
                disabled={isSaving}
              >
                Cancel
              </button>
              <button
                onClick={handleSaveProfile}
                disabled={isSaving || !hasUnsavedChanges}
                className="btn btn--primary"
              >
                {isSaving ? (
                  <>
                    <span className="btn__spinner"></span>
                    Saving Profile...
                  </>
                ) : (
                  'üíæ Save Changes'
                )}
              </button>
            </div>
            
            {hasUnsavedChanges && (
              <p className="profile-edit__footer-note">
                üí° Don't forget to save your changes before leaving this page
              </p>
            )}
          </div>

        </div>
      </main>
    </div>
  )
}

/**
 * üõ†Ô∏è Fonctions utilitaires pour la gestion des donn√©es
 * 
 * Ces fonctions illustrent le principe de "separation of concerns" en s√©parant
 * la logique de transformation de donn√©es de la logique d'interface utilisateur.
 */

// D√©termination de l'endpoint selon le type d'utilisateur
const getProfileEndpoint = (userType) => {
  const endpoints = {
    player: '/api/players/profile',
    coach: '/api/coaches/profile', 
    njcaa_coach: '/api/njcaa-coaches/profile',
    admin: '/api/admin/profile'
  }
  return endpoints[userType] || '/api/auth/me'
}

// Normalisation des donn√©es selon le sch√©ma de formulaire
const normalizeProfileData = (apiData, userType) => {
  // Cette fonction transforme les donn√©es de l'API en format de formulaire
  // en g√©rant les diff√©rences de structure selon le type d'utilisateur
  const baseData = {
    firstName: apiData.firstName || '',
    lastName: apiData.lastName || '',
    email: apiData.email || '',
    phoneNumber: apiData.phoneNumber || ''
  }
  
  // Ajout de champs sp√©cifiques selon le type
  switch (userType) {
    case 'player':
      return {
        ...baseData,
        position: apiData.playerProfile?.position || '',
        height: apiData.playerProfile?.height || '',
        weight: apiData.playerProfile?.weight || '',
        gpa: apiData.playerProfile?.gpa || ''
      }
    case 'coach':
    case 'njcaa_coach':
      return {
        ...baseData,
        coachingExperience: apiData.coachProfile?.experience || '',
        specialization: apiData.coachProfile?.specialization || '',
        collegeId: apiData.coachProfile?.collegeId || ''
      }
    default:
      return baseData
  }
}

// Validation sp√©cifique aux joueurs
const validatePlayerSpecificFields = (data) => {
  const errors = {}
  
  if (data.height && !/^\d{1,2}'\d{1,2}"?$/.test(data.height)) {
    errors.height = 'Height must be in format like 5\'10"'
  }
  
  if (data.weight && (isNaN(data.weight) || data.weight < 50 || data.weight > 500)) {
    errors.weight = 'Weight must be a valid number between 50 and 500 lbs'
  }
  
  if (data.gpa && (isNaN(data.gpa) || data.gpa < 0 || data.gpa > 4)) {
    errors.gpa = 'GPA must be between 0.0 and 4.0'
  }
  
  return errors
}

// Validation sp√©cifique aux coachs
const validateCoachSpecificFields = (data) => {
  const errors = {}
  
  if (!data.coachingExperience) {
    errors.coachingExperience = 'Coaching experience is required'
  }
  
  if (!data.collegeId) {
    errors.collegeId = 'Institution affiliation is required'
  }
  
  return errors
}

// Transformation des donn√©es pour l'API
const transformProfileDataForAPI = (formData, userType) => {
  // Cette fonction pr√©pare les donn√©es du formulaire pour l'envoi √† l'API
  // en respectant le format attendu par le backend
  const basePayload = {
    firstName: formData.firstName,
    lastName: formData.lastName,
    email: formData.email,
    phoneNumber: formData.phoneNumber
  }
  
  // Ajout de donn√©es sp√©cifiques dans des sous-objets
  switch (userType) {
    case 'player':
      return {
        ...basePayload,
        playerProfile: {
          position: formData.position,
          height: formData.height,
          weight: parseFloat(formData.weight) || null,
          gpa: parseFloat(formData.gpa) || null
        }
      }
    case 'coach':
    case 'njcaa_coach':
      return {
        ...basePayload,
        coachProfile: {
          experience: formData.coachingExperience,
          specialization: formData.specialization,
          collegeId: parseInt(formData.collegeId) || null
        }
      }
    default:
      return basePayload
  }
}

export default ProfileEdit